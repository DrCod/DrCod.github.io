---
title: 'Introduction to Practical Machine Learning - Part I'
date: 2020-02-03
permalink: /posts/2020/02/blog-post-2/
---

This is the first part of our machine learning practical tutorial. In this tutorial , we get a quick and broad overview of python programming language, as a pre-requisite for our next tutorial.

_Key Terms and Definitions_
* _Programming language_ : a computer language progammers use to write a detailed set of instructions for a computer to execute
* _Python library_ : a collection of sets of instructions used by a python program to execute a task 
* _Data type_ : a category a data belong, telling how it should be used  
* _Syntax_ : rules that specifiy the correct combined sequence of symbols that a computer can interpret
* _Unicode_ : the standard for encoding and handling text in a computing system 
* _Debugging_: process of finding and resolving errors within a computer program
* _Arguments_: what you pass into your computer program
* _Iterable_ : any datatype that can be iterated over e.g strings, lists, tuples and python's other collection data types.
  
  
If you are a beginner to Python, this is a good starting point for you. If you are already familiar with Python, this is certainly a refreshing tutorial for you.

**Tutorial Requirements**
* Install Python
    Python is one of the several programming languages out there,and certainly one of the most popular programming languages in machine learning. It comes pre-packaged and designed to work on different computer operating systems(OS).Depending your computer OS type and version, follow any of the links below and get started with installation(if you do not have one already).

  * [Windows 64-bit](https://www.python.org/ftp/python/3.8.1/python-3.8.1-amd64.exe)
  * [Windows 32-bit](https://www.python.org/ftp/python/3.8.1/python-3.8.1.exe)
  * [Mac OS X](https://www.python.org/ftp/python/3.8.1/python-3.8.1-macosx10.9.pkg)  
  * [Other platforms](https://www.python.org/download/other/)

* _Get a quick review of my previous tutorial, if you have not done so._


**Quick Python Overview** 

Once python is installed, create an empty file from the default python IDLE programming environment(for Windows and Mac OS X),give it a name and add the ".py" extension. The advantage with using the IDLE is, it allows you to enter python expressions and code, and to see your results directly in the python shell. Alternatively, you can choose to use Notepad. You may also like to check out the following text editors ; Sublime, Jupyter Notebook,Visual Studio,Atom etc. However, my recommendation is to start with the python IDLE. Now let's dive in!


  * _Data Types_

  Python gives several built-in data types.
   * _int_ : used to represent positive and negative whole numbers. Examples - **-973, 210624583337114373395836055367340864637790190801098222508621955072, 0, etc**
    - Due to the computer memory limitations, an integer can not exceed **2<sup>217</sup>**
   * _str_ : used to represent strings, a sequence of unicode characters. Examples - **"Dagaare","Twi", "Tamale", "Jollof Rice"**

   **[]** - Python uses a square bracket to access an element from a sequence such as a string. Example,
    `word-wrap: >>> "Python"[3] >>> "h" break-word;`<br/>
    `word-wrap: >>> "Lawra"[0] >>> "L" break-word;`<br/>
    
    _VIP_: 
    * Another data type , the floating point values comprises the built-in _float_,_decimal_, and  _complex_ types. They are all immutable.
    * Numbers of type _float_ are written with a decimal point or using an exponential notation ,for example, _6.6, 5.6,-6e6_.  
    * All python index positions start at 0.
    * Both _str_ and _int_ are immutable - meaning, once you set their values, you can not change them.
    * A character is a string with a length of 1.

    **_datatype(item)_** - the general syntax used to convert a data item from one type into another.

    `word-wrap: >>> int("77") break-word;``word-wrap: >>> 77 break-word;`<br/>
    
    The line above converts  "77", of string type to an integer 77.

    `word-wrap: >>> str(123) break-word;``word-wrap: >>> "123" break-word;`<br/>

    The line above converts an integer 123 to a string "123"

    **_type(data item)_** - finds the type or class that the data item belongs. This is very important in testing and debugging your code. Alternatively, **isintance()** is also achieves the same result but much efficiently and hence it is mostly used in production. Example,
    
    `word-wrap: >>> region ="Western" break-word;``word-wrap: >>> print(region,type(region)) # prints: Western <class 'str'> break-word;`<br/>

   * **Collection Data Types**

   Python provides several data types for holding collections of data items of any data types. Here we will only look at _list_ and _tuple_.
 * _list_ - holds any number of data items of any data types and are _mutable_(can be changed once they are created). Meaning, we can insert ,update or delete items whenever we want.
   * _[]_ - represents a list. List examples, [1,2,3,4], ['alpha','beta','gamma'],['human',99,-234,'neon',0], []. The last example represents an empty list.
 * _tuple_ - holds any number of data items of any data types and are _immutable_. 
   * _(,)_ - represents tuple. Example, 

   `word-wrap: >>> "one", "two","three" break-word;``word-wrap: ('one','two','three') break-word;`<br/>

   `word-wrap: >>> "Ghana" break-word;``word-wrap: ('Ghana',)  break-word;`<br/>

_VIP_ 
  * You can nest collection data types inside other collection data types. Example,
  [[1,2,3],["old",5, "boy"],[0,"-7",-9]] is an example of a nested list, aka list of lists.
  * _len()_ - takes a single data item as its argument, and returns the "length" of the items as an _int_. Examples, 
  
  `word-wrap: >>> len(("one",)) break-word;``word-wrap: 1 break-word;` <br/>

  `word-wrap: >>> len([3,5,8,"football"]) break-word;``word-wrap:  4  break-word;`<br/>

  `word-wrap: >>> len("classroom") 9 break-word;`  `word-wrap: 9 break-word;`

  * _list_, _tuple_ and _str_ data types are  the types _len()_ is applied to.
  * _append()_ - adds a new item to a list of items. Example, 
  `word-wrap: >>> myNames = ["Polle","Tuurime"] break-word;`<br/>
  `word-wrap: >>> myNames.append("Ronny") >>>myNames ['Polle','Tuurime','Ronny']  break-word;`<br/>
  `word-wrap: >>> myNames  break-word;`
  `word-wrap: ['Polle','Tuurime','Ronny']  break-word;`<br/>

  *_extend()_ - appends a  list of items to an original list of items. Example,
  `word-wrap: >>> myNames.extend(["Dikpe","24"]) break-word;`
  `word-wrap: ['Polle','Tuurime','Ronny','Dikpe','24'] break-word;`<br/>

  *_List indexing with []_ - Let us find the names in <var>myNames<var> at a given position using the index operator _[]_,
  
  `word-wrap: >>> myNames[0] break-word;` `word-wrap: 'Polle' break-word;`<br/>
  `word-wrap: >>> myNames[2] break-word;` `word-wrap: 'Ronny' break-word;`<br/>
  `word-wrap: >>> myNames[-1] break-word;` `word-wrap: '24' break-word;`<br/>
   
   _-1 is the index of the last item in a list_

   * To insert an item into a given index of <var>myNames</var>, example,
    `word-wrap: >>> myNames[1] = "Polley"  break-word;`<br/>
    `word-wrap: >>> myNames  'Polle'  ['Polle','Polley','Ronny','Dikpe','24'] break-word;`<br/>

    Inserting into a given index replaces the item originally at that position.

  * _Object References_

    In this section, we look at how you can store your data of various types once you have created them. And you need a container,called a _variable_, to store this data. In fact in python, everything is an object, including _variables_. We create and set an object reference to refer to a particular value. Thus, <var>objectReference = value</var>. Example,
    `word-wrap: >>> x = "boy" break-word;`<br/>
    `word-wrap: >>> y = "girl" break-word;`<br/>
    `word-wrap: >>> z = x break-word;`<br/>
    When executed, python creates a _str_ object with the text "boy", and an object reference called x that refers to the _str_ object. In other words,  the string "boy" is stored in a variable ,x. The second line is similar to the first. The third line, however,creates an object reference z, and set it to refere to the same _str_ object that x is refering to.

    Now, `word-wrap: >>> print(x,y,z) #prints: boy girl boy break-word;`<br/>

    _VIP_ 
    * some terms are reserved for python only, and so they **must** not be used as _variable_ names. Example of reserved python keywords are _is, in, and, def, for, while etc_.


  * _Identity Operators_ - **is**

     Examples,
     `word-wrap: >>> a = ["boy",5,None] break-word;`
     `word-wrap: >>>  a = ["boy",5,None] break-word;` <br/>
     `word-wrap: >>> a is b break-word;`
     `word-wrap: False break-word;`<br/>
    
    `word-wrap: >>> a = b break-word;`<br/>
    `word-wrap: >>> a is b  break-word;` 
    `word-wrap: True break-word;`<br/>

    `word-wrap: >>> c = None break-word;`<br/>
    `word-wrap: >>> a is not None, c is None  break-word;`
    `word-wrap: (True,True) break-word;`<br/>


  * _Comparison Operators_ - **<, <=,==,!= ,>=,>**
    
    `word-wrap: >>> a = 2  break-word;`
    `word-wrap: >>> b = 6  break-word;`
    * _<_ - less than. `word-wrap: >>> a < b  break-word;` `word-wrap: True break-word;`
    * _<=_ - less than or equal to. `word-wrap: >>> a <= b  break-word;` `word-wrap: True break-word;`
    * _==_ - equal to. `word-wrap: >>> a == b  break-word;` `word-wrap: False break-word;`
    * _!=_ - not equal to. `word-wrap: >>> a != b  break-word;` `word-wrap: True break-word;`
    * _>_ - greater than. `word-wrap: >>> a > b  break-word;` `word-wrap: True break-word;`
    For strings,`word-wrap: >>> a = "words"  break-word;` <br/>
   `word-wrap: >>> b = "words"  break-word;`<br/>

   `word-wrap: >>> a is b  break-word;` `word-wrap: >>> False  break-word;`<br/>
   `word-wrap: >>> a == b  break-word;` `word-wrap: >>> True  break-word;`<br/>

    
  * _Membership Operator_ - **in**

   `word-wrap: >>> p = (5, "bag",-4, 100) break-word;`<br/> 
   `word-wrap: >>> 7 in p  break-word; ``word-wrap: >>> False  break-word; `<br/>
   `word-wrap: >>> "bag" in p  break-word; ``word-wrap: >>> True  break-word; `<br/>
   `word-wrap: >>> 5 in p  break-word; ` `word-wrap: >>> True  break-word; `<br/>
   `word-wrap: >>> 66 not in p  break-word; ` `word-wrap: >>> True  break-word; `


  * _Logical Operators_ - **and, or, and not**

    These operations uses short circuit logic and only returns the operand that determined the result and not a boolean. However, in a boolean context(true or false), operations returns True or False.
    Examples,

    `word-wrap: >>> five = 5 break-word;`<br/>
    `word-wrap: >>> three = 3  break-word;`<br/>
    `word-wrap: >>> seven = 7 break-word;`<br/>
    `word-wrap: >>> zero = 0 break-word;`<br/>

    `word-wrap: >>> seven and five break-word;``word-wrap: 5 break-word;`<br/>
    `word-wrap: >>> seven and zero break-word;``word-wrap: 0 break-word;`<br/>
    `word-wrap: >>> five and seven break-word;``word-wrap: 7 break-word;`<br/>

   `word-wrap: >>> seven or five break-word;``word-wrap: 7  break-word;`<br/>
   `word-wrap: >>> zero or five break-word;``word-wrap: 0 break-word;`<br/>
   `word-wrap: >>> five or seven break-word;``word-wrap: 5 break-word;`<br/>


  * _Control Flow Statements_ 

    * _The **if** Statement_  - A statement that will execute its body , if the boolean expression evaluates as  true. Here is its general syntax,

     if _boolean_expression1_:
       _body1_
    elif _boolean_expression2_:
       _body2_
    ...
    elif _boolean_expressionN_:
        _bodyN_
    else:
        something_else

    Example, 
    `word-wrap:>>> age = 65 break-word;`<br/>
    `word-wrap:>>> if age < 18: print("Adolescent") elif age >= 18: print("Adult") else: print("Undefined")  break-word;`<br/>

    * _The **while** Statement_ - A statement whose body executes zero or more times, the number of times depending on the truth value of the while's loop boolean expression evaluation. Here is its general syntax,

        _while boolean_expression:_
            _body_
    
    Example, `word-wrap: >>> steps = 9  break-word;`<br/>
    Example, `word-wrap: >>> while steps: print("True") steps = steps - 1 break-word;`<br/>

    * _The **for ... in** Statement - A statement that executes a set number of times by setting a _variable_ to refer to each object in an iterable after each turn.
    Example, `word-wrap: >>> for country in ["Ghana","Nigeria","Niger","Finland"]: print(country) break-word;`

    In practice, it is much convenient to use a variable to represent the list of countries.

    _countries = ["Ghana","Spain","Niger","Finland"]_<br/>
     `word-wrap: >>> for country in countries: print(country) break-word;`
    
    You can even print the entire list by simply using 
    `word-wrap: >>> print(countries) break-word;`<br/>

  * _Arithmetic Operatons_ - Python provides a complete set of arithmetic operators, including binary operators for basic mathematical operations i.e _+_ for addition, _*_ for multiplication, _-_ for substraction, and _/_ for division.
  Examples, 
  `word-wrap: >>> 6 + 5 break-word;``word-wrap: 11 break-word;`<br/>
  `word-wrap: >>> 6 - 5 break-word;``word-wrap: -1 break-word;`<br/>
  `word-wrap: >>> 6 * 5 break-word;``word-wrap: 30 break-word;`<br/>
  `word-wrap: >>> 12 / 3 break-word;``word-wrap: 4.0 break-word;`<br/>

  If we want an integer result from division , we either use _int()_ or _//_ i.e   `word-wrap: >>> 3 / 2 break-word;``word-wrap: 1.5 break-word;`<br/>
  `word-wrap: >>> 3 // 2 break-word;``word-wrap: 1 break-word;`<br/>

    * _Augmented Operators_ - _-=,+=, *=,/=_

      * _a-=b_ - a = a - b
      * _a+=b_ - a = a + b
      * _a*=b_ - a = a * b
      * _a/=b_ - a = a / b

      `word-wrap: >>> age = 56 break-word;`<br/>
      `word-wrap: >>> age += 2 break-word;``word-wrap: 58 break-word;`<br/>
      `word-wrap: >>> age -= 2 break-word;``word-wrap: 56 break-word;`<br/>
      `word-wrap: >>> age /= 2 break-word;``word-wrap: 28 break-word;`<br/>
      `word-wrap: >>> age *= 2 break-word;``word-wrap: 56 break-word;`<br/>

      `word-wrap: >>> name = "Polle" break-word;`<br/>
      `word-wrap: >>> name += " Ronny" break-word;``word-wrap:"Polle Ronny" break-word;`

      `word-wrap: >>> items = ["book",5,"pen"] break-word;`<br/>
      Now let's apply the augmented addition operator to a list and see the outcome, 
      
      `word-wrap: >>> items += 2 break-word;``word-wrap: TypeError: 'int' object is not iterable break-word;`<br/>
      
      But... we are getting an error here. What's going on? We are trying to add a _non-iterable_,an integer to an iterable. Now ,how do we resolve this? 
     
      `word-wrap: >>> items += [2] break-word;``word-wrap: ['book',5,'pen',2] break-word;`<br/> 
      It appears that this operator equally works fine for iterables. Yaay!

  * _Functions_ 

    No one likes boring repetitive tasks. Same applies to computer programs. And because we will want a piece of our software program to be re-used at different points in time, so is the need for functions. Functions enable code packaging and reusability. It prevents re-writing the same piece of code several times in your program.

    Here is the general syntax for creating a python function, 

    _def functionName(arguments):_
        _body_

    Let us write a function that will return "old" or "young" , given your age. We will apply concepts from what we learnt using the _list_ data type.
     
    _def youngOrOld(age):_
        _status = ["old","young"]_
        _if age < 18:_
          _return status[1]_
        _else:_
            _return status[0]_

    A function can be used in python code by _**import**ing_ the function. The imported function ,with all its functionalities becomes available ,and used inside where you are making the import. Another term used for this kind of python function is a _module_. Once a module is imported into a python code, we can access any functions,classes,or variables that it contains. An example of an import statement,

    `word-wrap: >>> import moduleName break-word;`<br/>

    In general, the syntax for using a function in a module is _moduleName.functionName(arguments)_. It makes use of the dot operator aka access attribute operator.

    Let us look at this example , the random module, a python standard library's file which provides many useful functions.

   `word-wrap: >>> import random break-word;`<br/>
   `word-wrap: >>> x = random.randint(1,6) break-word;`<br/>
   `word-wrap: >>> y = random.choice(["apple","pineapple","orange"]) break-word;`<br/>

    Now run the code above in your text editor and see what you get. 

   _VIP_
   * A function must do one and only one specific task.
   * The _arguments_ are optional and if multiple, must be separated by commas.
   * Every function has a return value. 
   * The return value is defaulted to None, unless we return from the function using _return value_.
   * The return value is not necessarily one value, but can be a tuple or list of multiple values.
    

**Upcoming Tutorial: _Practical Machine Learning with Python, Part  II _**






